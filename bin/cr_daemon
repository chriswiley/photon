#!/usr/photon/freebsd_i386/bin/tclsh8.0


# Commands we accept

# write <byte>
# setsync <byte>
# read true/false
# enable true/false


namespace eval Conf {
  source /var/photon/game.conf
}

load $Conf::libpath/ph_cr.so
source $Conf::gamepath/photon_vals
source $Conf::gamepath/photon_interfaces

set streaming_sockets { }
set cr_lock 0
# generate fake data
set fakeit 1
# for a game of max_slot on max_slot
set max_slot 10

proc sputs { sock message } {
  if { [ catch [ list puts $sock $message ] stuff ] } {
    puts "write error to socket $sock ($stuff)"
  }
}

proc sflush { sock } {
  if { [ catch [ flush $sock ] stuff ] } {
    puts "flush error to socket $sock ($stuff)"
  }
}


proc Accept { newSock addr port } {
  variable outbuffer_$newSock { }

  puts "connection from $addr/$port"

  fileevent $newSock readable [ list ServerRead $newSock ]

  fconfigure $newSock -blocking 0
  
  trace variable outbuffer_$newSock w ServerStreamWriteBuffer
}


proc cr_handler { } {
  variable fakeit
  lappend cr_list [ cr_read ]
  foreach msg $cr_list {    
    ServerStreamWrite "905 $msg"
    if { $fakeit == 1 } {
      FakeIt "$msg"
    }
  }
}

proc FakeIt { msg } {
      variable max_slot
      # Parse message, look for sync
      set list_msg [ split $msg " " ]
      set serialnum [ lindex $list_msg 0 ]
      set slot [ lindex $list_msg 1 ]
      set action [ lindex $list_msg 2 ]
      set data [ lindex $list_msg 3 ]
      if { $slot == 0 && $data == $::Photon::GSYNC } {
        for { set i $::Photon::RED_RFSTART } { 
              $i < $::Photon::RED_RFSTART + $max_slot } { incr i } {
          ServerStreamWrite "905 [ GenRandomForSlot $serialnum $i ]"
        }
        for { set i $::Photon::GRN_RFSTART } {
              $i < $::Photon::GRN_RFSTART + $max_slot } { incr i } {
          ServerStreamWrite "905 [ GenRandomForSlot $serialnum $i ]"
        }
      }
}

proc ServerStreamWrite { string } {
  variable streaming_sockets
  foreach x $streaming_sockets {
    variable outbuffer_$x
    lappend outbuffer_$x $string
  }
}
proc ServerStreamWriteBuffer { name element op } {
   
  # suck the socketname out of name
  set sock [ lindex [ split $name "_" ] 1 ]
  variable outbuffer_$sock
  upvar 0 outbuffer_$sock buffer

  # write out contents of buffer
  foreach x $buffer {
      sputs $sock $x
      set buffer [ lreplace $buffer 0 0 ]
  }
  sflush $sock
}

proc ServerHandler_WRITE { sock line } {
  set byte [ lindex $line 1 ]
  cr_write $byte
  sputs $sock "100-WRITE $byte"
}

proc ServerHandler_SETSYNC { sock line } {
  set sync [ lindex $line 1 ]
  set valid { PSYNC ESYNC GSYNC }
  foreach x $valid {
    if { "$x" == "$sync" } {
      if { $sync == "PSYNC" } {
        ResetRandomState
      }
      cr_setsync $x
      sputs $sock "100 SYNC $x"
      break
    }
  }
  if { "$x" != "$sync" } {
    sputs $sock "503 Unknown Sync"
  }
}

proc ServerHandler_ENABLE { sock line } {
  set arg [ lindex $line 1 ]
  if { "$arg" == "ON" } {
     cr_enable 1
     puts "cr enabled"
     sputs $sock "100 OK Enabled"
  } else {
     cr_enable 0
     puts "cr disabled"
     sputs $sock "100 OK Disabled"
  }
}

proc ServerHandler_READ { sock line } {
  variable streaming_sockets
  set arg [ lindex $line 1 ]
  if { "$arg" == "OFF" } {
    if { [ lsearch -exact $streaming_sockets $sock ] != -1 } {
      set streaming_sockets [ lreplace $streaming_sockets [ lsearch -exact $streaming_sockets $sock ] [ lsearch -exact $streaming_sockets $sock ] ]
      set count [ llength $streaming_sockets ]
      sputs $sock "100 OK ($count streaming)"
      sflush $sock
    } else {
      sputs $sock "101 NOT STREAMING"
      sflush $sock
    }
  } else {
    if { [ lsearch -exact $streaming_sockets $sock ] != -1 } {
      sputs $sock "101 ALREADY STREAMING"
      sflush $sock
    } else {
      lappend streaming_sockets $sock
      set count [ llength $streaming_sockets ]
      sputs $sock "100 OK ($count streaming)"
      sflush $sock
    }
  }
}

proc ServerRead { sock } {
  variable streaming_sockets
  if [ eof $sock ] {
    if { [ lsearch $streaming_sockets $sock ] != -1 } {
      set j [ lsearch $streaming_sockets $sock ]
      set streaming_sockets [ lreplace $streaming_sockets $j $j ]
    }
    catch { close $sock }
    return -code ok
  }
  if { [ gets $sock line ] < 0 } {
  } else {
    set j [ split $line " " ]
    set command [ lindex $j 0 ]
    set commands { WRITE SETSYNC READ ENABLE }
    foreach x $commands {
      if { $x == $command } {
        ServerHandler_$command $sock $j
        sflush $sock
        break
      }
    }
    if { $x != $command } {
      sputs $sock "503 Unknown Command"
      sflush $sock
    }
  }
  return -code ok
}

proc ResetRandomState { } {
  variable random_state
  for { set x 0 } { $x < 67 } { incr x } {
	  set random_state($x) 0
  }
}

proc GenRandomForSlot { serial slot } {
  variable random_state

  if { [ expr { rand() * 300 } ] < 1 } {
    set random_state($slot) [ MyBase $slot ]
  }

  if { [ expr { rand() * 6 } ] < 1 } {
    return "$serial $slot rx [ RandomDouche $slot ]"
  }

  if { $random_state($slot) == 0 } {
    return "$serial $slot rx [ ::Photon::id_to_sig $slot ]"
  } else {
    return "$serial $slot rx $random_state($slot)"
  }
}

proc RandomDouche { slot } {
  variable max_slot
  if { $slot < $::Photon::GRN_RFSTART } {
    set base $::Photon::GRNIR
  } else {
    set base $::Photon::REDIR
  }
  set it [ expr { $base + int(rand() * $max_slot) } ]

  if { $it == $::Photon::GRNIR } {
    set it 0x94
  }
  return [ expr { $it } ]
}


proc MyBase { slot } {
  if { $slot < $::Photon::GRN_RFSTART } {
    return [ expr { $::Photon::GBASE } ]
  } else {
    return [ expr { $::Photon::RBASE } ]
  }
}

cr_init
cr_enable 1
ResetRandomState
set cr_Socket [ socket -server Accept 40000 ]
set dummy 0
vwait dummy
    

