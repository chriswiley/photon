
namespace eval :: {

set cr_pending { }
set cr_sock ""

proc cr_newdata { sock } {
  variable cr_sock
  if { [ eof $sock ] } {
    variable cr_sock
    close $cr_sock
    cr_reconnect
    return -code ok
  }
  if { [ catch [ list cr_readdata $sock ] stuff ]} {
    puts "cr_readdata failed $stuff"
  }
  cr_readdata $sock
}


proc cr_setsync { sync } {
  variable cr_sock
  cr_sputs $cr_sock "SETSYNC $sync"
  cr_sflush $cr_sock
}

proc cr_read { } {
  variable cr_sock
  variable cr_pending
  set cr_returned $cr_pending
  set cr_pending { }
  return $cr_returned
}

proc cr_write { byte } {
  variable cr_sock
  cr_sputs $cr_sock "WRITE $byte"
  cr_sflush $cr_sock
}

proc cr_enable { on } {
  variable cr_sock

  set mode "OFF"
  if { "$on" == "1" } {
    set mode "ON"
  }
  cr_sputs $cr_sock "ENABLE ON"
  cr_sflush $cr_sock

  cr_sputs $cr_sock "READ ON"
  cr_sflush $cr_sock
}

proc cr_readdata { sock } {
  variable cr_sock
  variable cr_pending
  
  if { [ eof $sock ] } {
    return -code ok
  }

  if { [ gets $sock line ] < 0 } {
  } else {
    set e [ split $line {} ]
    set code [ join [ lrange $e 0 2 ] "" ]
    set message [ join [ lrange $e 4 end ] "" ]
    set stuff [ split $message " " ]

    if { $code == 905 } {
      lappend cr_pending "$message"
    } else {
      puts $line
    }
  }
  
  if { [ catch [ list ::Photon::cr_handler ] stuff ] } {
    puts "cr_handler failed $stuff"
  }

  return -code ok
}

proc cr_sputs { sock message } {
     
    if { [ catch [ list puts $sock $message ] stuff ] } {
        ::warninglog "write error to socket $sock ($stuff)"
    }
    
}

proc cr_sflush { sock } {
    
    if { [ catch [ flush $sock ] stuff ] } {
        ::warninglog "flush error to socket $sock ($stuff)"
    }
}   

proc cr_init { } {
  variable cr_sock
  cr_reconnect
}

proc cr_reconnect { } {
  variable cr_sock

  set rc [ catch "socket $::Conf::cr_server_name $::Conf::cr_listenport" s ]
  if { $rc != 0 } {
    puts "Failed to open CR connection... sleeping $::Conf::cr_server_name $::Conf::cr_listenport"
    after 1000 cr_reconnect
    return -code ok
  }
  fconfigure $s -buffering line
  fconfigure $s -blocking 0

  fileevent $s readable [ list ::cr_newdata $s ]

  set cr_sock $s
}

}